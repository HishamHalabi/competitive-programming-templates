struct Euler {
    int n, edges = 0;
    vector<vector<pair<int,int>>> g; // {to, edge_id}
    vector<bool> used;

    Euler(int n) : n(n) {
        g.assign(n + 1, {});
    }

    void add_edge(int u, int v) {
        g[u].push_back({v, edges});
        g[v].push_back({u, edges});
        edges++;
    }

    void dfs(int u, vector<int>& path) {
        while (!g[u].empty()) {
            auto [v, id] = g[u].back();
            g[u].pop_back();

            if (used[id]) continue;
            used[id] = true;

            dfs(v, path);
            path.push_back(id); // store edge id
        }
    }

    int find_start() {
        int start = -1;
        int odd = 0;

        for (int i = 1; i <= n; i++) {
            if (g[i].size() % 2) {
                odd++;
                start = i;
            }
            if (start == -1 && !g[i].empty())
                start = i;
        }

        if (!(odd == 0 || odd == 2))
            return -1;

        return start;
    }

    vector<int> get_edges_path() {
        used.assign(edges, false);

        int start = find_start();
        if (start == -1) return {};

        vector<int> path;
        dfs(start, path);

        if ((int)path.size() != edges)
            return {}; // not connected

        reverse(path.begin(), path.end());
        return path;
    }
};
