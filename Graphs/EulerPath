/* 
for undircted Graph trying to assign edges direction
//////////////////////////

    path that start from some node visit all edges once and
       if all deg[nd[%2 ==  >> return to the start node  >> this path callerd >>  Euler cycle 

     to have Euler path  in directed graph >> deg[anyNd]%2 == 0  except for 0 or 2 nodes  
       //          cycle      deg[anyNd]%2 == 0
 

   in Euler path  >> only 0 or  2nds break in[nd] = out[nd]    
   //     cycle >> 0 break //


 ////////////
handle multi edges
////
return path in form of edges
//////////////////////

*/
 
struct Edge {
    int id, u, v;
};
 
struct Euler {
    int n;
    vector<vector<pair<int, int>>> g;
    vector<Edge> edges;
    vector<bool> used;
    vector<int> ptr;
 
    Euler(int n) : n(n), g(n + 1) {}
 
    void add_edge(int id, int u, int v) {
        g[u].push_back({v, id});
        g[v].push_back({u, id});
        if (id >= (int)edges.size()) edges.resize(id + 1);
        edges[id] = {id, u, v};
    }
 
    vector<Edge> get_single_path(int start_node) {
        vector<Edge> path;
        stack<int> st;
        stack<Edge> edge_st;
        st.push(start_node);
 
        while (!st.empty()) {
            int u = st.top();
            bool found = false;
 
            while (ptr[u] < (int)g[u].size()) {
                auto [v, id] = g[u][ptr[u]++];
                if (used[id]) continue;
 
                used[id] = true;
                st.push(v);
                edge_st.push({id, u, v});
                found = true;
                break;
            }
 
            if (!found) {
                if (!edge_st.empty()) {
                    path.push_back(edge_st.top());
                    edge_st.pop();
                }
                st.pop();
            }
        }
        reverse(path.begin(), path.end());
        return path;
    }
 
    vector<vector<Edge>> get_all_paths() {
        int max_id = 0;
        for (const auto& e : edges) if (e.id > max_id) max_id = e.id;
 
        used.assign(max_id + 1, false);
        ptr.assign(n + 1, 0);
        vector<vector<Edge>> all_paths;
 
        vector<int> starts;
        for (int i = 1; i <= n; i++) {
            if (g[i].size() % 2 != 0) starts.push_back(i);
        }
        for (int i = 1; i <= n; i++) {
            starts.push_back(i);
        }
 
        for (int s : starts) {
            bool has_unused = false;
            for (auto& p : g[s]) {
                if (!used[p.second]) {
                    has_unused = true;
                    break;
                }
            }
            if (has_unused) {
                vector<Edge> p = get_single_path(s);
                if (!p.empty()) all_paths.push_back(p);
            }
        }
        return all_paths;
    }
};
