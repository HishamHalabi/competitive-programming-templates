/*

  keep propogate in its positoion here !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! as it;s related to extend and acessing nullptr

*/










/*
   صل على محمد
   if (u == Abdel-Aziz Mostafa )   love u <3 ;
   دايما احلم ربنا المنان
*/

#include <bits/stdc++.h>
using namespace std;

#define int long long
//#define F first
#define S second

#define item int

struct node {
    bool op = 0;
    int oper = 0;
    int val =  0 ;
    int lx = 0, rx = 0;
    node *lft = nullptr, *rght = nullptr;

    node() {}

    void extend() {
        if (rx - lx == 1) return;

        int md = (lx + rx) / 2;

        if (!lft) {
            lft = new node();
            lft->lx = lx;
            lft->rx = md;
        }
        if (!rght) {
            rght = new node();
            rght->lx = md;
            rght->rx = rx;
        }
    }
};

struct segtree {
    node *root;
    int sz = 1;

    item NeutralELement ;
    segtree(int n) {
        while (sz < n) sz <<= 1;
        root = new node();
        root->lx = 0;
        root->rx = sz;
        NeutralELement =-1e18 ;
    }

    item merge(item a, item b) {
        return max(a , b) ;
    }

    int operation(int a, int b, bool op) {
        if (!op) return b;
        return a+b;
    }

    void apply(int &a, int b, bool op) {
        a = operation(a, b, op);
    }

    void update(node *nd) {
         nd->val +=  nd->oper;
    }

    void reset(node *nd) {
        if (nd->rx - nd->lx == 1) {
            nd->val = 0 ;
            if (nd->op) update(nd);
            return;
        }

        nd->extend() ;
        nd->val = merge(nd->lft->val , nd->rght->val) ;
        if (nd->op)
               update(nd);
    }

    void propagate(node *nd) {
        nd->extend();
        if (!nd->op) return;
        apply(nd->lft->oper, nd->oper, nd->lft->op);
        apply(nd->rght->oper, nd->oper, nd->rght->op);

        nd->lft->op = nd->rght->op = 1;

        nd->op = 0;
        nd->oper = 0;

        reset(nd->lft);
        reset(nd->rght);
        reset(nd);
    }

    void change(int l, int r, int oper, node *nd) {

       


        if (nd->rx <= l || nd->lx >= r) return;


        if (nd->lx >= l && nd->rx <= r) {
            apply(nd->oper, oper, nd->op);
            nd->op = 1;
            reset(nd);
            return;
        }

         propagate(nd) ;
        change(l, r, oper, nd->lft);
        change(l, r, oper, nd->rght);
        nd->val = merge(nd->lft->val, nd->rght->val);
    }

    void change(int l, int r, int oper) {
        change(l, r, oper, root);
    }

    item calc (int l ,  int r , node * nd)  {


         int lx = nd->lx , rx = nd->rx;
         if ( l  >=rx  || lx>=r) {
                  return  NeutralELement  ;
         }


         if  (lx>=l and rx<=r) {
                   return nd->val ;
         }
             

         propagate(nd);

         item res1 = calc(l , r , nd->lft) ;
         item res2 = calc(l  ,r  , nd->rght) ;
         item res=  merge(res1 ,res2) ;
         return res;
    }

    item calc(int  l ,  int r) {
            return calc(  l ,r   , root) ;
    }


};


void testCases()  {
     int n;
     cin >> n ;



     const int SH_SEQ =  1e15 ,MX =1e15;

     vector < int > a(n+1)  , dp(n+1) ;
     for  (int  i =1; i <=n  ;  ++i)  {
                cin >> a[i] ;
     }

     //a[i]  + sh1 =  sg  +sh2

     segtree sg(1e18) ;
     sg.change(1+SH_SEQ , 1e18 , -1e18) ;
   ;

     int sh1 = 0 ,  sh2 = 0  ;
     for  (int  i = 1; i<=n ; ++i) {


                dp[i]  = max(dp[i-1] , (int)(a[i]  >= 0));
                int mx =  sg.calc(-a[i] - sh1  +  SH_SEQ ,  MX-sh1  + SH_SEQ) ;


                sh1+=a[i] ;
                sh2++ ;
                dp[i] = max(dp[i] , mx+sh2);

                int v1=  sg.calc(-sh1  +  SH_SEQ  ,  -sh1 +1+  SH_SEQ);
                sg.change( - sh1  +  SH_SEQ  , -sh1 +  SH_SEQ+1 , -v1);

                sg.change(  - sh1  +  SH_SEQ  , -sh1 +  SH_SEQ +1, max(v1 ,   (dp[i]  - sh2)) );


     }

     cout <<dp[n] <<"\n";



}


signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int tc;
    cin >> tc;
    while (tc--) {
        testCases() ;
    }
}
