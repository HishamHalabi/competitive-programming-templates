/*
   صل عل محمد
   if (u == Abdel-Aziz Mostafa )   love u <3 ;
  دايما احلم ربنا المنان

*/
#include<bits/stdc++.h>
using namespace std;
const int N = 5e5  ,  mod =1e9+7 , p1 =51 ;

int sub(int a , int b   ){
    return (a%mod - b%mod + mod)%mod;
}

vector<int > pw1(N)  ;

#define N 300007
//#define mod 1000
#define int long long
#define F first
#define S second

int power(int a, int b){

    if(b < 0) return 1;
    int res = 1;
    while(b){
        if(b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return    res;
}

struct item  {
     int v  ;
     int op  ;      // 0 assign        |  1 add
struct custom_hash {
    static uint64_t splitmix64(uint64_t x) {
// http://xorshift.di.unimi.it/splitmix64.c
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }
    size_t operator()(uint64_t x) const {
        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};
unordered_map < int , int , custom_hash>  mp ;
int mod_inv(int  b)  {
    if (mp.find(b) != mp.end())return mp[b] ;
    return  mp[b] = power(b   , mod-2)  ;
}
int Div  (int a , int b)  {
    a%=mod ;
    b%=mod;
    return a  * mod_inv(b)%mod ;
}

int geo_seq(int p   , int  n)  {
        int up = (power(p , n)-1 + mod)%mod ;
        int down = (p-1+mod)%mod;
        return Div(up , down) ;
}


#define item int


struct segtree{



vector <int> op;
    vector <item>  operations;
    vector <int > val ;
    vector <int >  operations;
    vector <item > val ;

int sz =1;
segtree(int n){         //empty
@@ -34,48 +69,34 @@ struct segtree{
op.resize(2*sz);
val.resize(2*sz) ;

        pw1[0] = 1 ;
        for (int  i = 1 ; i <= 2*sz; ++i) {
            pw1[i] = (pw1[i-1]*p1)%mod;
        }
}
    int Neutral_elemnt  = 0 ;

    int merge(int m1  ,  int m2 , int len){
          return  m1 + m2 ;
    item Neutral_elemnt = -1 ;
    item merge(item m1  ,  item m2 , int len){
          if (m1 == -1)return m2 ;
          if (m2 == -1) return m1;
          item ret  = m1 ;
          ret+= m2*pw1[len];
          ret%=mod;
          return ret;
}

    item operation (item a ,  item b , int x){
        if (!op[x])
            return  b ;

        int v1  = a.v , v2 = b.v , op1 = a.op , op2 =b.op;
        item res ;
        if (op2){
                if (op1){
                    res.op =1;
                    res.v = v1  +v2;
                }
                else {
                    res.op =  0 ;
                    res.v =  v1+v2;
                }
        }
        else{
                res.op = 0 ;
                res.v =   v2 ;
        }
        return res;
    int  operation (int  a , int  b , int x){
            return b;
}

    void apply(item& a ,item b , int x){
    void apply(int & a ,int  b , int x){
a=operation (a, b ,x);
}
    void update(int & cur  , item oper , int len){
          if (oper.op)
               cur+=len*oper.v;
          else
               cur =len*oper.v;
    void update(item & cur  , int  oper , int len){
           cur =   (oper    *    geo_seq(p1   , len) )%mod;
}
void reset (int x , int  lx ,int rx){
if (rx- lx==1){
             val[x] = 0 ;
             val[x] =0 ;
if (op[x])
update(val[x] , operations[x]  , 1) ;
}
@@ -85,6 +106,7 @@ struct segtree{
update(val[x] , operations[x] , rx-lx ) ;
}
}

void propagate(int x  , int lx  ,int rx){
if (rx-lx==1 || !op[x])
return  ;
@@ -100,13 +122,10 @@ struct segtree{
reset(2*x+2, md, rx); //same
reset(x , lx, rx);    //same
////////////////////////////////////////////////////



}


    void change  (int  l , int r,item oper , int x, int lx ,  int rx){
    void change  (int  l , int r,int  oper , int x, int lx ,  int rx){
propagate(x , lx, rx);
if (rx<=l || lx>=r)
return  ;
@@ -122,10 +141,10 @@ struct segtree{

val[x] = merge(val[2*x+1] , val[2*x+2] , (rx-lx)/2) ;
}
    void change (int  l ,int r ,item oper){
    void change (int  l ,int r ,int  oper){
change(l,r , oper,0 ,0,sz);
}
    int calc( int  l,  int r , int x , int lx , int rx ){
    item calc( int  l,  int r , int x , int lx , int rx ){

propagate(x,lx,rx);
if (lx>=r  ||rx<=l)
@@ -134,58 +153,17 @@ struct segtree{
return val[x] ;
}


int md  =  (lx+rx)/2;
          int res1 = calc( l , r , 2*x+1 ,lx ,md);
          int res2 = calc( l , r, 2*x+2 , md, rx) ;
          return merge(res1 , res2 , rx-lx);
          item res1 = calc( l , r , 2*x+1 ,lx ,md);
          item res2 = calc( l , r, 2*x+2 , md, rx) ;
            int len1 = max(0LL, min(md, r) - max(lx, l));
          return merge(res1 , res2 , len1);

}
    int calc(int l,  int r){
    item calc(int l,  int r){
return calc(l , r , 0, 0, sz) ;
}


};
signed main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);


    int n, m ;
    cin>>n>>m;
    segtree sg(n+1);




    for (int  i = 0 ; i  <m; ++i)
    {
         int q;
         cin>>q;
         if (q==1)
         {
                int l  , r ,v ;
                cin>>l>>r>>v;
                sg.change( l ,r ,{v, 0});

         }
         else if (q==2)
         {
                int l  , r ,v ;
                cin>>l>>r>>v;
                sg.change( l ,r ,{v, 1});

         }
         else
         {
             int l , r;
             cin>>l>>r;
             cout<<sg.calc( l ,r) <<"\n";
         }

    }



}
