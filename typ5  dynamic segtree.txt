
#define item int

struct node {
    bool op = 0;
    int oper = 0;
    int val =  0 ;
    int lx = 0, rx = 0;
    node *lft = nullptr, *rght = nullptr;

    node() {}

    void extend() {
        if (rx - lx == 1) return;

        int md = (lx + rx) / 2;

        if (!lft) {
            lft = new node();
            lft->lx = lx;
            lft->rx = md;
        }
        if (!rght) {
            rght = new node();
            rght->lx = md;
            rght->rx = rx;
        }
    }
};

struct segtree {
    node *root;
    int sz = 1;

    item NeutralELement ;
    segtree(int n) {
        while (sz < n) sz <<= 1;
        root = new node();
        root->lx = 0;
        root->rx = sz;
        NeutralELement = 0 ;
    }

    item merge(item a, item b) {
        return max(a , b) ;
    }

    int operation(int a, int b, bool op) {
        if (!op) return b;
        return b;
    }

    void apply(int &a, int b, bool op) {
        a = operation(a, b, op);
    }

    void update(node *nd) {
         nd->val +=  nd->oper;
    }

    void reset(node *nd) {
        if (nd->rx - nd->lx == 1) {
            nd->val =0;
            if (nd->op) update(nd);
            return;
        }

        nd->extend() ;
        nd->val = merge(nd->lft->val , nd->rght->val) ;
        if (nd->op)
               update(nd);
    }

    void propagate(node *nd) {
        nd->extend();
        if (!nd->op) return;

        apply(nd->lft->oper, nd->oper, nd->lft->op);
        apply(nd->rght->oper, nd->oper, nd->rght->op);

        nd->lft->op = nd->rght->op = 1;

        nd->op = 0;
        nd->oper = 0;

        reset(nd->lft);
        reset(nd->rght);
        reset(nd);
    }

    void change(int l, int r, int oper, node *nd) {
        if (nd->rx <= l || nd->lx >= r) return;

        if (nd->lx >= l && nd->rx <= r) {
            apply(nd->oper, oper, nd->op);
            nd->op = 1;
            reset(nd);
            return;
        }

        propagate(nd);
        change(l, r, oper, nd->lft);
        change(l, r, oper, nd->rght);

        nd->val = merge(nd->lft->val, nd->rght->val);
    }

    void change(int l, int r, int oper) {
        change(l, r, oper, root);
    }

    item calc (int l ,  int r , node * nd)  {
         nd->extend();
         propagate(nd);

         int lx = nd->lx , rx = nd->rx;
         if ( l  >=rx  || lx>=r) {
                  return  NeutralELement  ;
         }

          if  (l>=lx and r<=rx) {
                   return nd->val ;
         }

         item res1 = calc(l , r , nd->lft) ;
         item res2 = calc(l  ,r  , nd->rght) ;
         item res=  merge(res1 ,res2) ;
         return res;
    }

    item calc(int  l ,  int r) {
            return calc(  l ,r   , root) ;
    }


};
