//Add(l , r, v)  max(l , r,v)  min( l ,r,v)    >> l , r are inclusive
#define int long long

#include <bits/stdc++.h>
using namespace std;

struct Node {
    long long sum;
    long long max1, max2;
    long long min1, min2;
    int cntMax, cntMin;
    long long add;
    Node()
        : sum(0),
          max1(LLONG_MIN), max2(LLONG_MIN),
          min1(LLONG_MAX), min2(LLONG_MAX),
          cntMax(0), cntMin(0), add(0) {}
};

struct SegmentTreeBeats {
    int n;
    vector<Node> t;

    SegmentTreeBeats(int n_ = 0) { init(n_); }

    void init(int n_) {
        n = n_;
        if (n == 0) return;
        t.assign(4 * n, Node());
    }

    void build(const vector<long long> &a, int v, int l, int r) {
        if (l == r) {
            long long x = a[l];
            auto &nd = t[v];
            nd.sum = x;
            nd.max1 = x; nd.max2 = LLONG_MIN; nd.cntMax = 1;
            nd.min1 = x; nd.min2 = LLONG_MAX; nd.cntMin = 1;
            nd.add = 0;
            return;
        }
        int m = (l + r) >> 1;
        build(a, v<<1, l, m);
        build(a, v<<1|1, m+1, r);
        pull(v);
    }

    void build(const vector<long long> &a) {
        if (n == 0) return;
        build(a, 1, 0, n-1);
    }

    // ====== Core push/pull helpers ======
    void apply_add(int v, long long x, int len) {
        auto &nd = t[v];
        nd.sum += x * len;
        if (nd.max1 != LLONG_MIN) nd.max1 += x;
        if (nd.max2 != LLONG_MIN) nd.max2 += x;
        if (nd.min1 != LLONG_MAX) nd.min1 += x;
        if (nd.min2 != LLONG_MAX) nd.min2 += x;
        nd.add += x;
    }

    void push_chmin_node(int v, long long x) {
        auto &nd = t[v];
        if (x >= nd.max1) return;
        nd.sum -= 1LL * (nd.max1 - x) * nd.cntMax;
        nd.max1 = x;
        if (nd.min1 > nd.max1) nd.min1 = nd.max1;
    }

    void push_chmax_node(int v, long long x) {
        auto &nd = t[v];
        if (x <= nd.min1) return;
        nd.sum += 1LL * (x - nd.min1) * nd.cntMin;
        nd.min1 = x;
        if (nd.max1 < nd.min1) nd.max1 = nd.min1;
    }

    void push_down(int v, int l, int r) {
        auto &nd = t[v];
        if (l == r) {
            nd.add = 0;
            return;
        }
        int m = (l + r) >> 1;
        int lc = v<<1, rc = v<<1|1;

        if (nd.add != 0) {
            apply_add(lc, nd.add, m - l + 1);
            apply_add(rc, nd.add, r - m);
            nd.add = 0;
        }

        if (t[lc].max1 > nd.max1) push_chmin_node(lc, nd.max1);
        if (t[rc].max1 > nd.max1) push_chmin_node(rc, nd.max1);

        if (t[lc].min1 < nd.min1) push_chmax_node(lc, nd.min1);
        if (t[rc].min1 < nd.min1) push_chmax_node(rc, nd.min1);
    }

    void pull(int v) {
        auto &a = t[v<<1], &b = t[v<<1|1], &c = t[v];
        c.sum = a.sum + b.sum;

        // max
        if (a.max1 == b.max1) {
            c.max1 = a.max1;
            c.cntMax = a.cntMax + b.cntMax;
            c.max2 = max(a.max2, b.max2);
        } else if (a.max1 > b.max1) {
            c.max1 = a.max1;
            c.cntMax = a.cntMax;
            c.max2 = max(a.max2, b.max1);
        } else {
            c.max1 = b.max1;
            c.cntMax = b.cntMax;
            c.max2 = max(a.max1, b.max2);
        }

        // min
        if (a.min1 == b.min1) {
            c.min1 = a.min1;
            c.cntMin = a.cntMin + b.cntMin;
            c.min2 = min(a.min2, b.min2);
        } else if (a.min1 < b.min1) {
            c.min1 = a.min1;
            c.cntMin = a.cntMin;
            c.min2 = min(a.min2, b.min1);
        } else {
            c.min1 = b.min1;
            c.cntMin = b.cntMin;
            c.min2 = min(a.min1, b.min2);
        }
    }

    // ====== Range Updates ======
    void range_chmin(int v, int l, int r, int ql, int qr, long long x) {
        if (r < ql || l > qr || t[v].max1 <= x) return;
        if (ql <= l && r <= qr && t[v].max2 < x) {
            push_chmin_node(v, x);
            return;
        }
        push_down(v, l, r);
        int m = (l + r) >> 1;
        range_chmin(v<<1, l, m, ql, qr, x);
        range_chmin(v<<1|1, m+1, r, ql, qr, x);
        pull(v);
    }

    void range_chmax(int v, int l, int r, int ql, int qr, long long x) {
        if (r < ql || l > qr || t[v].min1 >= x) return;
        if (ql <= l && r <= qr && t[v].min2 > x) {
            push_chmax_node(v, x);
            return;
        }
        push_down(v, l, r);
        int m = (l + r) >> 1;
        range_chmax(v<<1, l, m, ql, qr, x);
        range_chmax(v<<1|1, m+1, r, ql, qr, x);
        pull(v);
    }

    void range_add(int v, int l, int r, int ql, int qr, long long x) {
        if (r < ql || l > qr) return;
        if (ql <= l && r <= qr) {
            apply_add(v, x, r - l + 1);
            return;
        }
        push_down(v, l, r);
        int m = (l + r) >> 1;
        range_add(v<<1, l, m, ql, qr, x);
        range_add(v<<1|1, m+1, r, ql, qr, x);
        pull(v);
    }

    // ====== Range Queries ======
    long long range_sum(int v, int l, int r, int ql, int qr) {
        if (r < ql || l > qr) return 0;
        if (ql <= l && r <= qr) return t[v].sum;
        push_down(v, l, r);
        int m = (l + r) >> 1;
        return range_sum(v<<1, l, m, ql, qr) + range_sum(v<<1|1, m+1, r, ql, qr);
    }

    long long range_max(int v, int l, int r, int ql, int qr) {
        if (r < ql || l > qr) return LLONG_MIN;
        if (ql <= l && r <= qr) return t[v].max1;
        push_down(v, l, r);
        int m = (l + r) >> 1;
        return max(range_max(v<<1, l, m, ql, qr), range_max(v<<1|1, m+1, r, ql, qr));
    }

    long long range_min(int v, int l, int r, int ql, int qr) {
        if (r < ql || l > qr) return LLONG_MAX;
        if (ql <= l && r <= qr) return t[v].min1;
        push_down(v, l, r);
        int m = (l + r) >> 1;
        return min(range_min(v<<1, l, m, ql, qr), range_min(v<<1|1, m+1, r, ql, qr));
    }

    pair<long long,int> range_max_freq(int v, int l, int r, int ql, int qr) {
        if (r < ql || l > qr) return {LLONG_MIN, 0};
        if (ql <= l && r <= qr) return {t[v].max1, t[v].cntMax};
        push_down(v, l, r);
        int m = (l + r) >> 1;
        auto L = range_max_freq(v<<1, l, m, ql, qr);
        auto R = range_max_freq(v<<1|1, m+1, r, ql, qr);
        if (L.first == R.first) return {L.first, L.second + R.second};
        return (L.first > R.first ? L : R);
    }

    pair<long long,int> range_min_freq(int v, int l, int r, int ql, int qr) {
        if (r < ql || l > qr) return {LLONG_MAX, 0};
        if (ql <= l && r <= qr) return {t[v].min1, t[v].cntMin};
        push_down(v, l, r);
        int m = (l + r) >> 1;
        auto L = range_min_freq(v<<1, l, m, ql, qr);
        auto R = range_min_freq(v<<1|1, m+1, r, ql, qr);
        if (L.first == R.first) return {L.first, L.second + R.second};
        return (L.first < R.first ? L : R);
    }

    int count_equal(int v, int l, int r, int ql, int qr, long long x) {
        if (r < ql || l > qr) return 0;
        if (ql <= l && r <= qr) {
            if (x == t[v].max1) return t[v].cntMax;
            if (x == t[v].min1) return t[v].cntMin;
            return 0; // only fast for min/max queries
        }
        push_down(v, l, r);
        int m = (l + r) >> 1;
        return count_equal(v<<1, l, m, ql, qr, x) + count_equal(v<<1|1, m+1, r, ql, qr, x);
    }

    long long point_get(int v, int l, int r, int idx) {
        if (l == r) return t[v].sum;
        push_down(v, l, r);
        int m = (l + r) >> 1;
        if (idx <= m) return point_get(v<<1, l, m, idx);
        return point_get(v<<1|1, m+1, r, idx);
    }

    // ====== User-friendly wrappers ======
    void chmin(int l, int r, long long x) { if (l>r) return; range_chmin(1, 0, n-1, l, r, x); }
    void chmax(int l, int r, long long x) { if (l>r) return; range_chmax(1, 0, n-1, l, r, x); }
    void add(int l, int r, long long x)   { if (l>r) return; range_add(1, 0, n-1, l, r, x); }
    long long sum(int l, int r)           { if (l>r) return 0; return range_sum(1, 0, n-1, l, r); }
    long long get(int i)                  { return point_get(1, 0, n-1, i); }
    long long rangeMax(int l, int r)      { return range_max(1, 0, n-1, l, r); }
    long long rangeMin(int l, int r)      { return range_min(1, 0, n-1, l, r); }
    long long rangeDiff(int l, int r)     { return rangeMax(l, r) - rangeMin(l, r); }
    double rangeAvg(int l, int r)         { return 1.0 * sum(l, r) / (r - l + 1); }
    pair<long long,int> rangeMaxFreq(int l, int r) { return range_max_freq(1, 0, n-1, l, r); }
    pair<long long,int> rangeMinFreq(int l, int r) { return range_min_freq(1, 0, n-1, l, r); }
    int countEqual(int l, int r, long long x) { return count_equal(1, 0, n-1, l, r, x); }
};
