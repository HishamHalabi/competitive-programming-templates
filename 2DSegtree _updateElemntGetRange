/*
 Build n*m*logn logm
 query  ,  update point  logn , logm
*/


#include <bits/stdc++.h>
using namespace std;

template <typename T>
struct SegTree2D {
    int n, m;
    T NEUTRAL;
    function<T(T, T)> merge;
    vector<vector<T>> tree;

    SegTree2D(int n, int m, T neutral, function<T(T, T)> merge)
        : n(n), m(m), NEUTRAL(neutral), merge(merge) {
        tree.assign(4 * n, vector<T>(4 * m, NEUTRAL));
    }

    void build(const vector<vector<T>>& a, int vx, int lx, int rx) {
        if (lx == rx) {
            build_y(a, vx, lx, rx, 1, 0, m - 1);
        } else {
            int mx = (lx + rx) / 2;
            build(a, vx * 2, lx, mx);
            build(a, vx * 2 + 1, mx + 1, rx);
            build_y(a, vx, lx, rx, 1, 0, m - 1);
        }
    }

    void build_y(const vector<vector<T>>& a, int vx, int lx, int rx, int vy, int ly, int ry) {
        if (ly == ry) {
            if (lx == rx) tree[vx][vy] = a[lx][ly];
            else tree[vx][vy] = merge(tree[vx * 2][vy], tree[vx * 2 + 1][vy]);
        } else {
            int my = (ly + ry) / 2;
            build_y(a, vx, lx, rx, vy * 2, ly, my);
            build_y(a, vx, lx, rx, vy * 2 + 1, my + 1, ry);
            tree[vx][vy] = merge(tree[vx][vy * 2], tree[vx][vy * 2 + 1]);
        }
    }

    void update(int x, int y, T val) { update_x(1, 0, n - 1, x, y, val); }

    void update_x(int vx, int lx, int rx, int x, int y, T val) {
        if (lx == rx) {
            update_y(vx, lx, rx, 1, 0, m - 1, x, y, val);
        } else {
            int mx = (lx + rx) / 2;
            if (x <= mx) update_x(vx * 2, lx, mx, x, y, val);
            else update_x(vx * 2 + 1, mx + 1, rx, x, y, val);
            update_y(vx, lx, rx, 1, 0, m - 1, x, y, val);
        }
    }

    void update_y(int vx, int lx, int rx, int vy, int ly, int ry, int x, int y, T val) {
        if (ly == ry) {
            if (lx == rx) tree[vx][vy] = val;
            else tree[vx][vy] = merge(tree[vx * 2][vy], tree[vx * 2 + 1][vy]);
        } else {
            int my = (ly + ry) / 2;
            if (y <= my) update_y(vx, lx, rx, vy * 2, ly, my, x, y, val);
            else update_y(vx, lx, rx, vy * 2 + 1, my + 1, ry, x, y, val);
            tree[vx][vy] = merge(tree[vx][vy * 2], tree[vx][vy * 2 + 1]);
        }
    }

    T query(int x1, int y1, int x2, int y2) { return query_x(1, 0, n - 1, x1, x2, y1, y2); }

    T query_x(int vx, int lx, int rx, int x1, int x2, int y1, int y2) {
        if (x2 < lx || rx < x1) return NEUTRAL;
        if (x1 <= lx && rx <= x2) return query_y(vx, 1, 0, m - 1, y1, y2);
        int mx = (lx + rx) / 2;
        return merge(
            query_x(vx * 2, lx, mx, x1, x2, y1, y2),
            query_x(vx * 2 + 1, mx + 1, rx, x1, x2, y1, y2)
        );
    }

    T query_y(int vx, int vy, int ly, int ry, int y1, int y2) {
        if (y2 < ly || ry < y1) return NEUTRAL;
        if (y1 <= ly && ry <= y2) return tree[vx][vy];
        int my = (ly + ry) / 2;
        return merge(
            query_y(vx, vy * 2, ly, my, y1, y2),
            query_y(vx, vy * 2 + 1, my + 1, ry, y1, y2)
        );
    }
};
